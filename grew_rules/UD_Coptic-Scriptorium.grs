strat main { 
  Seq(
    Onf(interrogatives),
    Onf(existentials),
    Onf(conditionals),
    Onf(npn)
  )
}

package interrogatives {

  rule InterrogativeWh { 
    pattern {
      PAR -[re"root\|ccomp"]-> GOV; 
      PINT[xpos="PINT"]; 
      GOV -> PINT;
      GOV[!Cxn]
    }	
    commands {GOV.Cxn=Interrogative-Wh}
  }

  rule InterrogativePolar { 
    global { text_en = re".*\?" }
    pattern{
        ROOT -["root"]-> TOK; 
        TOK[!Cxn,xpos<>PINT];
    }
    without {PINT[xpos="PINT"]}
    without {WHADV[lemma="ⲡⲱⲥ"]}
    commands {TOK.Cxn=Interrogative-Polar}
  }
}

package npn {

    rule NPN { 
      pattern {
        N [ xpos = re"N.*" ];
        N2 [xpos = re"N.*" ];
        N.lemma = N2.lemma;
        N -> N2;
        N2 -[case]-> P;
        N < P;
        P < N2;
        N[!Cxn];
      }
      without {
        N -[case]-> P2;
        P2 << N
      }
      commands {N.Cxn=NPN}
    }

    rule NPN_bis { 
      pattern {
        N [xpos = re"N.*" ];
        N2 [xpos = re"N.*" ];
        N.lemma = N2.lemma;
        N -> N2;
        N2 -[case]-> P;
        N < P;
        P < N2;
        N[Cxn<>re".*NPN.*"];
      }
      without {
        N -[case]-> P2;
        P2 << N
      }
      commands {N.Cxn=N.Cxn + "," + "NPN"}
    }
}

package condtionals {

  rule ConditionRealisticConjunction { 
    pattern {
      CONJ [ lemma = re"ⲉϣϫⲉ\|ⲉϣⲱⲡⲉ" ];
      MAIN -[advcl]-> ADVCL;
      ADVCL -> CONJ;
      ADVCL[!Cxn];
    }
    commands {ADVCL.Cxn=Conditional-Realistic}
  }

  rule ConditionRealisticConjunction_bis { 
    pattern {
      CONJ [ lemma = re"ⲉϣϫⲉ\|ⲉϣⲱⲡⲉ" ];
      MAIN -[advcl]-> ADVCL;
      ADVCL -> CONJ;
      ADVCL[Cxn<>re".*Conditional-Realistic.*"];
    }
    commands {ADVCL.Cxn = ADVCL.Cxn + "," + "Conditional-Realistic"}
  }

  rule ConditionRealisticAux { 
    pattern {
    MAIN -[advcl]-> ADVCL;
    CONJ [ xpos=re"ACOND.*"];
    ADVCL -> CONJ;
    ADVCL[!Cxn];
    }
    without {
      AUX [xpos=FUT];
      PRET [xpos=CPRET];
      MAIN -> AUX;
      MAIN -> PRET;
    }
    commands {ADVCL.Cxn=Conditional-Realistic}
  }

  rule ConditionRealisticAux_bis { 
    pattern {
    MAIN -[advcl]-> ADVCL;
    CONJ [ xpos=re"ACOND.*"];
    ADVCL -> CONJ;
    ADVCL[Cxn<>re".*Conditional-Realistic.*"];
    }
    without {
      AUX [xpos=FUT];
      PRET [xpos=CPRET];
      MAIN -> AUX;
      MAIN -> PRET;
    }
    commands {ADVCL.Cxn= ADVCL.Cxn + "," + "Conditional-Realistic"}
  }

  rule ConditionUnrealistic { 
    pattern {
      MAIN -[advcl]-> ADVCL;
      AUX [xpos=FUT];
      MAIN -> AUX; 
      PRET [xpos=CPRET];
      MAIN -> PRET;
      ADVCL[!Cxn];
    }
    commands {ADVCL.Cxn=Conditional-Unrealistic}
  }

  rule ConditionUnrealistic_bis { 
    pattern {
      MAIN -[advcl]-> ADVCL;
      AUX [xpos=FUT];
      MAIN -> AUX; 
      PRET [xpos=CPRET];
      MAIN -> PRET;
      ADVCL[Cxn<>".*Conditional-Unrealistic.*"];
    }
    commands {ADVCL.Cxn=ADVCL.Cxn + "," + "Conditional-Unrealistic"}
  }
}

package existentials {

  rule ExistentialPositive { 
    pattern {
      EXIST [lemma="ⲟⲩⲛ",xpos=EXIST];
      EXIST -[nsubj]-> SBJ;
      EXIST[!Cxn];
    }
    commands {EXIST.Cxn=Existential-Positive}
  }

  rule ExistentialPositive_bis { 
    pattern {
      EXIST [lemma="ⲟⲩⲛ",xpos=EXIST];
      EXIST -[nsubj]-> SBJ;
      EXIST[Cxn<>re".*Existential-Positive.*"];
    }
    commands {EXIST.Cxn=EXIST.Cxn + "," + "Existential-Positive"}
  }

  rule ExistentialNegative { 
    pattern {
      EXIST [lemma="ⲙⲛ",xpos=EXIST];
      EXIST -[nsubj]-> SBJ;
      EXIST[!Cxn];
    }
    commands {EXIST.Cxn=Existential-Negative}
  }

  rule ExistentialNegative_bis { 
    pattern {
      EXIST [lemma="ⲙⲛ",xpos=EXIST];
      EXIST -[nsubj]-> SBJ;
      EXIST[Cxn<>re".*Existential-Negative.*"];
    }
    commands {EXIST.Cxn=EXIST.Cxn + "," + "Existential-Negative"}
  }
}