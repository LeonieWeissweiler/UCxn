strat main { 
  Seq(
    Onf(conditionals),
    Onf(existentials),
    Onf(interrogatives),
    Onf(npn)
    )
}

package conditionals {
  rule Cond1 { 
    pattern { 
      X [form="so"|"wenn"|"falls"|"sofern"|"soweit"|"So"|"Wenn"|"Falls"|"Sofern"|"Soweit", upos=SCONJ];
    }
    without{
      A[lemma="auch"|"selbst"|"Auch"|"Selbst"];
      X-[advmod]->A;
    }
    commands {X.Cxn=Condition-MarkerSimple}
  }

  rule Cond2 { 
    pattern { 
      X[form="Angenommen"|"Vorausgesetzt"|"Unterstellt"];
      Y1[form<>"dass"|"daß"];
      Y2[form<>"dass"|"daß"];
      X < Y1;
      Y1 < Y2;
    }
    commands {X.Cxn=Condition-MarkerSimple}
  }

  rule Cond3 { 
    pattern { 
      X[form="angenommen"|"vorausgesetzt"|"unterstellt"];
      Y1[form<>"dass"|"daß"];
      Y2[form<>"dass"|"daß"];
      A[upos=ADV];
      A < X;
      X < Y1;
      Y1 < Y2;
      root[form="__0__"];
      root<A;
    }
    commands {X.Cxn=Conditional-MarkerSimple}
  }

  rule Cond4 { 
    pattern { 
      V1[upos=VERB|AUX,Mood<>Imp];
      root[form="__0__"];
      root<V1;
      P[upos=PUNCT];
      V1 << P;
      V2[upos=VERB|AUX];
      P < V2;
    }
    commands {V1.Cxn=Conditional-Inverted}
  }


  rule Cond5 { 
    pattern { 
      V1[upos=VERB|AUX,Mood<>Imp];
      root[form="__0__"];
      root<V1;
      P[upos=PUNCT];
      V1 << P;
      A[lemma="so"|"dann"];
      V2[upos=VERB|AUX];
      P < A;
      A < V2;
    }
    commands {V1.Cxn=Conditional-Inverted}
  }

}

package existentials {

  rule Ex1 { 
    pattern { 
      E[lemma="es"];
      G[lemma="geben"];
      G-[nsubj]->E;
    }
    commands {G.Cxn=Existential-Expl}
  }

  rule Ex2 { 
    pattern { 
      D[lemma="da",upos=ADV];
      I[lemma="sein",upos=AUX];
      D-[cop]->I;
    }
    commands {D.Cxn=Existential-There}
  }

}

package interrogatives {

rule IntDir { 
  pattern { 
    F[lemma="?", upos=PUNCT];
    H-[punct]->F;
    W[PronType="Int,Rel"|"Int"];
    W << F;
  } 
  commands {H.Cxn=Interrogative-WHInfo-Direct}
}

  rule IntDirPol { 
    pattern { 
      F[lemma="?", upos=PUNCT];
      H-[punct]->F;
    } 
    without {
      W[PronType="Int,Rel"];
    }
    without {
      WI[PronType="Int"];
    }
    commands {H.Cxn=Interrogative-Polar-Direct}
  }

  rule IntOb { 
    pattern{
      O[lemma=ob];
      X[upos=CCONJ|PUNCT];
      X < O;
    }
    commands {O.Cxn=Interrogative-Polar-Indirect}
  }

  rule IntIndWh { 
    pattern{
      O[PronType="Int"|"Int,Rel"];
      X[upos=CCONJ|PUNCT];
      X < O;
    }
    without{
      F[lemma="?"];
    }
    commands {O.Cxn=Interrogative-WHInfo-Indirect}
  }

  rule IntIndPrep { 
    pattern{
      O[PronType="Int"|"Int,Rel"];
      X[upos=CCONJ|PUNCT];
      A[upos=ADP];
      X < A;
      A < O;
    }
    without{
      F[lemma="?"];
    }
    commands {O.Cxn=Interrogative-WHInfo-Indirect}
  }

}

package npn {
  rule NPN { 
    pattern {
      N1[upos=NOUN];
      N2[upos=NOUN];
      N1.form = N2.form;
      P[upos=ADP];
      N1 < P;
      P < N2;
    }
    without{
      A[upos=ADP];
      A < N1;
    }
    commands {N1.Cxn=NPN}
  }

}
