strat main { 
    Seq(
        Onf(interrogatives),
        Onf(existentials),
        Onf(conditionals)
        %Onf(resultatives),
        %Onf(npn)
    )
}

package interrogatives {

    rule r1a { %  Main clause interrogatives (question mark)
        pattern { 
            Q [form="?", !Cxn] 
        }
        commands { Q.Cxn=Interrogative }
        }

%    rule r1b { % Direct polar interrogatives (Q y/n particle)
%        pattern { 
%            H [form="האם"];
%        }
%        without { Q [form="?", !Cxn] }
%        commands { Q.Cxn=Interrogative }
%    }

    rule r1c { % Embedded wh-question
        pattern {
            WH [upos=ADV,lemma=re"מי\|מה\|למה\|מדוע\|איפה\|היכן\|איה\|לאן\|מאין\|מתי\|איך\|כיצד\|כמה\|איזה", !Cxn]; 
            V [upos=VERB|ADJ]; 
            V -> WH
        }  
        without {X [lemma="?"]} 
        without {WH -[acl:relcl|acl]-> CL} 
        without {V -[nsubj]-> WH}
        commands { WH.Cxn=Interrogative }
    }

    rule r1d { % Embedded subject question
        pattern { 
            MI [lemma=re"מי\|מה", upos=ADV, !Cxn]; 
            V -[nsubj]-> MI 
        } 
        without {MI -[acl:relcl]-> RC} 
        without {X [form="?"]}
        commands { MI.Cxn=Interrogative }
    }
}

package existentials {
    rule r3a { % Present tense existential
        pattern { 
            THERE [lemma="יש", !Cxn]; 
            THERE -[nsubj]->SUBJ 
        } 
        without {THERE-[obl]->N}
        without {LE[lemma="ל"]; N -[case]->LE}
        commands { THERE.Cxn=Existential }
    }

    rule r3a_bis { % Present tense existential
        pattern { 
            THERE [lemma="יש", Cxn<>re".*Existential.*"]; 
            THERE -[nsubj]->SUBJ 
        } 
        without {THERE-[obl]->N}
        without {LE[lemma="ל"]; N -[case]->LE}
        commands { THERE.Cxn= THERE.Cxn + "," + "Existential" }
    }

    rule r3c {
        pattern {  
            THERE [lemma="היה", !Cxn]; 
            THERE -[nsubj]->SUBJ; 
            THERE << SUBJ 
        }  
        without {THERE-[obl]->N}
        without {LE[lemma="ל"]; N-[case]->LE}
        commands { THERE.Cxn=Existential }
    }

    rule r3c_bis {
        pattern {  
            THERE [lemma="היה", Cxn<>re".*Existential.*"]; 
            THERE -[nsubj]->SUBJ; 
            THERE << SUBJ 
        }  
        without {THERE-[obl]->N}
        without {LE[lemma="ל"]; N -[case]->LE}
        commands { THERE.Cxn= THERE.Cxn + "," + "Existential" }
    }

    rule r3d { % Negative existence
            pattern { 
                THERE [lemma="אין", !Cxn]; 
                THERE -[nsubj]->SUBJ
            } 
            without {THERE-[obl]->N}
            without {LE[lemma="ל"]; N -[case]->LE}
            commands { THERE.Cxn=Existential }
        }

    rule r3d_bis { % Negative existence
            pattern { 
                THERE [lemma="אין", Cxn<>re".*Existential.*"]; 
                THERE -[nsubj]->SUBJ
            } 
            without {THERE-[obl]->N}
            without {LE[lemma="ל"]; N -[case]->LE}
            commands { THERE.Cxn= THERE.Cxn + "," + "Existential" }
        }

    rule r3e { % Verbal "exist"
        pattern {
            THERE [lemma="קיים", !Cxn]; 
            THERE -[nsubj]->SUBJ 
        } 
        without {THERE [HebBinyan="PIEL"]}
        commands { THERE.Cxn=Existential }
    }

    rule r3e_bis { % Verbal "exist"
        pattern {
            THERE [lemma="קיים", Cxn<>re".*Existential.*"]; 
            THERE -[nsubj]->SUBJ 
        } 
        without {THERE [HebBinyan="PIEL"]}
        commands { THERE.Cxn= THERE.Cxn + "," + "Existential" }
    }
}

package conditionals {

    rule r2a { % Realistic conditional
        pattern {
            IF [lemma=re"אם\|אילו\|לו", !Cxn]; 
            MAIN -[advcl]-> COND; 
            COND -[mark]-> IF
        } 
        without { KI [lemma="כי"]; IF < KI }
        commands { IF.Cxn= "Conditional" }
    }

    rule r2a_bis { % Realistic conditional
        pattern {
            IF [lemma=re"אם\|אילו\|לו", Cxn<>re".*Conditional.*"]; 
            MAIN -[advcl]-> COND; 
            COND -[mark]-> IF
        } 
        without { KI [lemma="כי"]; IF < KI }
        commands { IF.Cxn=IF.Cxn + "," + "Conditional" }
    }

    rule r2b { % Unrealistic conditional
        pattern {
            IF [lemma=re"אילו\|לו", !Cxn];
            HAYA [lemma="היה"] ; 
            MAIN -> HAYA ;MAIN -[advcl]-> COND; 
            COND -[mark]-> IF
        } 
        without { KI [lemma="כי"]; IF < KI }
        commands { IF.Cxn=Conditional }
    }

    rule r2b_bis { % Unrealistic conditional
        pattern {
            IF [lemma=re"אילו\|לו", Cxn<>re".*Conditional.*"];
            HAYA [lemma="היה"] ; 
            MAIN -> HAYA ;MAIN -[advcl]-> COND; 
            COND -[mark]-> IF
        } 
        without { KI [lemma="כי"]; IF < KI }
        commands { IF.Cxn=IF.Cxn + "," + "Conditional" }
    }

    rule r2c { % Conditional MWE
        pattern { 
            B [lemma="ב", !Cxn]; 
            M [lemma="מידה"]; 
            W [lemma="ו"]; 
            B<M; 
            M<W; 
            COND -[mark]-> B; 
            MAIN -[advcl]-> COND;
        }
        commands { B.Cxn=Conditional }
    }

    rule r2c_bis { % Conditional MWE
        pattern { 
            B [lemma="ב", Cxn<>re".*Conditional.*"]; 
            M [lemma="מידה"]; 
            W [lemma="ו"]; 
            B<M; 
            M<W; 
            COND -[mark]-> B; 
            MAIN -[advcl]-> COND 
        }
        commands { B.Cxn=B.Cxn + "," + "Conditional" }
    }

    rule r2d { % Conditional MWE
        pattern { 
            B [lemma="ב", !Cxn]; 
            M [lemma="תנאי"]; 
            W [lemma="ש"]; 
            B<M; 
            M<W; 
            COND -[mark]-> B; 
            MAIN -[advcl]-> COND 
        }
        commands { B.Cxn=Conditional }
    }

    rule r2d_bis { % Conditional MWE
        pattern { 
            B [lemma="ב", Cxn<>re".*Conditional.*"]; 
            M [lemma="תנאי"]; 
            W [lemma="ש"]; 
            B<M; 
            M<W; 
            COND -[mark]-> B; 
            MAIN -[advcl]-> COND 
        }
        commands { B.Cxn=B.Cxn + "," + "Conditional" }
    }

}







