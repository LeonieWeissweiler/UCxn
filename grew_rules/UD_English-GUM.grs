strat main { 
  Seq(
    Onf(conditionals),
    Onf(existentials),
    Onf(interrogatives),
    Onf(npn)
    )
}

package conditionals {

    rule cond1 { %reduced conditional
        pattern { 
            X -[advcl]-> Y;
            Y [!Cxn];
            Y -[mark]-> I;
            I [lemma="if"];
            }
        without { Y-[re".subj.*"]-> Z;}
        without {Y -[cop]-> Z2;}
        without {Y [xpos="VBZ"|"VBD"|"VBP"];}
        without{
            Y [xpos="VBN"|"VBG"];
            Y -[aux]-> Z3;}
        commands {Y.Cxn=Condition}
    }

    rule cond2 { %unrealistic modal conditional
        pattern { 
            X -[advcl]-> Y;
            Y -[mark]-> I;
            Y [!Cxn];
            I [form="if"];
            M [lemma="could"|"would"|"might"];
            M [xpos="MD"];
            H [lemma="have"];
            X -[aux]->H;
            X -> M;
        }
        commands {Y.Cxn=Condition}
    }

    rule cond3 { %unrealistic inverted conditional
        pattern { 
            X -[advcl]-> Y;
            M [lemma="could"|"would"|"might"];
            M [xpos="MD"];
            H [lemma="have"];
            X -[aux]->H;
            X -> M;
            Y -[re".subj.*"]-> S;
            H2 [lemma = "have"];
            Y [!Cxn];
            Y -> H2;
            H2 << S;
        }
        commands {Y.Cxn=Condition}
    }

    rule cond4 { %hypothetical modal conditional
        pattern { 
            X -[advcl]-> Y;
            Y [!Cxn];
            Y -[mark]-> I;
            I [lemma="if"];
            M [lemma="could"|"would"|"might"];
            M [xpos="MD"];
            X -> M;
            Y -[cop|aux]-> Z;
            Z [xpos = "VBD"];
        }
        without { X-[aux]-> H;}
        commands {Y.Cxn=Condition}
    }

    rule cond5 { %what-if conditional
        pattern { 
            X -[advcl]-> Y;
            Y [!Cxn];
            Y -[mark]-> M;
            M [form="if"];
            X [lemma="what"];
        }
        commands {Y.Cxn=Condition}
    }

    rule cond6 { %realistic conditional
        pattern { 
            X -[advcl]-> Y;
            Y [!Cxn];
            Y -[mark]-> M;
            M [form="if"];
        }
        global { s_type <> "wh"}
        commands {Y.Cxn=Condition}
    }

}

package existentials {

    rule ex1 { %exist lemma existentials
        pattern { 
            E [lemma="exist", !Cxn];
            E -[re".subj"]-> X;
        }
        commands {E.Cxn=Existential}
    }

    rule ex1_bis { %exist lemma existentials
        pattern { 
            E [lemma="exist", Cxn<>re".*Existential.*"];
            E -[re".subj"]-> X;
        }
        commands {E.Cxn=E.Cxn + "," + "Existential"}
    }

    rule ex2 { %existential there
        pattern { 
            E [lemma="be"|"exist"|"stretch", !Cxn];
            E -[re".subj"]-> X;
            E -> Y;
            Y [xpos="EX"];
        }
        commands {E.Cxn=Existential}
    }

    rule ex2_bis { %existential there
        pattern { 
            E [lemma="be"|"exist"|"stretch", Cxn<>re".*Existential.*"];
            E -[re".subj"]-> X;
            E -> Y;
            Y [xpos="EX"];
        }
        commands {E.Cxn=Y.Cxn + "," + "Existential"}
    }

    rule ex3 { %existential here
        pattern { 
            E [lemma="be", !Cxn];
            E -[re".subj"]-> X;
            E -> Y;
            Y [lemma="here"];
        }
        commands {E.Cxn=Existential}
    }

    rule ex3_bis { %existential here
        pattern {
            E [lemma="be", Cxn<>re".*Existential.*"];
            E -[re".subj"]-> X;
            E -> Y;
            Y [lemma="here"];
        }
        commands {E.Cxn=E.Cxn + "," + "Existential"}
    }

}

package interrogatives {

    rule int1 { %direct WH question
        pattern {
            R-[root]->V;
            V [!Cxn];
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"]
        }
        commands {V.Cxn=Interrogative}
    }

    rule int1_bis { %direct WH question
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"]
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }   

    rule int2 {%direct WH, whose question
        pattern {
            R-[root]->V;
            V [!Cxn];
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
            V -> N;
            N [xpos="NN"];
            N -> W;
            W [PronType=Int];
        }
        commands {V.Cxn=Interrogative}
    }

    rule int2_bis {%direct WH, whose question
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
            V -> N;
            N [xpos="NN"];
            N -> W;
            W [PronType=Int];
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }

    rule int3 { %no QM no inversion
        pattern {
            R-[root]->V;
            V [!Cxn];
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"];
            W << V
        }
        without { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        without { V-[cop|aux|aux:pass]->* }
        commands { V.Cxn=Interrogative }
    }

    rule int3_bis { %no QM no inversion
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"];
            W << V
        }
        without { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        without { V-[cop|aux|aux:pass]->* }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }

    rule int4 { %no QM subject aux inversion
        pattern {
            R-[root]->V;
            V [!Cxn];
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"];
            V-[cop|aux|aux:pass]->A;
            W << A
        }
        without { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        commands {V.Cxn=Interrogative}
    }

    rule int4_bis { %no QM subject aux inversion
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            V -> W;
            W [lemma = "who"|"what"|"when"|"how"|"why"|"which"|"whose"|"whom"|"where"];
            V-[cop|aux|aux:pass]->A;
            W << A
        }
        without { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }    

    rule int5 { %no QM wh-subject
        pattern {
            R-[root]->V;
            V [!Cxn];
            V -> W;
            W [PronType=Int];
        }
        with { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        commands {V.Cxn=Interrogative}
    }

    rule int5_bis { %no QM wh-subject
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            V -> W;
            W [PronType=Int];
        }
        with { V-[nsubj]->W }
        without { 
            V-[punct]-> Q;
            Q.lemma = re".*[?].*";
        }
        without {
            V-[det:predet]->W; % exclamative e.g. "what a"
        }
        without { V[upos=NOUN]; V-[det]->W } % exlamative e.g. "what stunning views"
        without { V[upos=ADJ]; V-[advmod]->W } % exclamative e.g. "how rare!"
        without { V-[nsubj:outer]->S; S << W }
        without { W-[acl:relcl]->X }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }

    rule int6 {%direct Wh question metadata
        global { s_type = "wh"}
        pattern {
            R-[root]->V;
            V [!Cxn];
            W [PronType=Int];
        }
        without {
            W -[reparandum]-> X;
            X [PronType=Int];
        }
        without {
            X -[reparandum]-> W;
            X [PronType=Int];
        }
        without {
            X -[advcl|acl:relcl]-> Y;
            Y -> W;
        }
        commands {V.Cxn=Interrogative}
    }

    rule int6_bis {%direct Wh question metadata
        global { s_type = "wh"}
        pattern {
            R-[root]->V;
            V [Cxn<>re".*Interrogative.*"];
            W [PronType=Int];
        }
        without {
            W -[reparandum]-> X;
            X [PronType=Int];
        }
        without {
            X -[reparandum]-> W;
            X [PronType=Int];
        }
        without {
            X -[advcl|acl:relcl]-> Y;
            Y -> W;
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }

    rule int7 {% direct YN metadata
        global { s_type = "q"}
        pattern {
            O -[root]-> X;
            X [!Cxn];
        }
        commands {X.Cxn=Interrogative}
    }

    rule int7_bis {% direct YN metadata
        global { s_type = "q"}
        pattern {
            O -[root]-> X;
            X [Cxn<>re".*Interrogative.*"];
        }
        commands {X.Cxn=X.Cxn + "," + "Interrogative"}
    }

    rule int8 {% direct YN no metadata
        pattern {
            R -[root]-> V; 
            V -[nsubj]-> N1;
            V -[aux]-> A;
            V [!Cxn];
            A << N1;
            V -[punct]-> Q;
            Q [form="?"];
        }
        without { 
            V -> W;
            W [lemma = "who"|"what"|"when"|"why"|"whom"|"which"|"whose"|"how"|"where"];
        }
        commands {V.Cxn=Interrogative}
        }

    rule int8_bis {% direct YN no metadata
        pattern {
            R -[root]-> V; 
            V -[nsubj]-> N1;
            V -[aux]-> A;
            V [Cxn<>re".*Interrogative.*"];
            A << N1;
            V -[punct]-> Q;
            Q [form="?"];
        }
        without { 
            V -> W;
            W [lemma = "who"|"what"|"when"|"why"|"whom"|"which"|"whose"|"how"|"where"];
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
        }

    rule int9 {%indirect YN
        pattern {
            V.xpos = re"V.*";
            V -[ccomp]-> X;
            V [!Cxn];
            X -[mark]-> Y;
            Y [lemma = "if"];
            V << Y;
        }
        commands {V.Cxn=Interrogative}
    }

    rule int9_bis {%indirect YN
        pattern {
            V.xpos = re"V.*";
            V -[ccomp]-> X;
            V [Cxn<>re".*Interrogative.*"];
            X -[mark]-> Y;
            Y [lemma = "if"];
            V << Y;
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }   

    rule int10 {%indirect wh
        pattern {
            V.xpos = re"V.*";
            V -[ccomp]-> X;
            V [!Cxn];
            X -> Y;
            Y [PronType=Int];
            V << Y;
        }
        commands {V.Cxn=Interrogative}
    }

    rule int10_bis {%indirect wh
        pattern {
            V.xpos = re"V.*";
            V -[ccomp]-> X;
            V [Cxn<>re".*Interrogative.*"];
            X -> Y;
            Y [PronType=Int];
            V << Y;
        }
        commands {V.Cxn=V.Cxn + "," + "Interrogative"}
    }    

}

package npn {

    rule npn {
        pattern {
            N [ xpos = re"N.*", !Cxn];
            N2 [xpos = re"N.*" ];
            N.lemma = N2.lemma;
            N -> N2;
            N2 -[case]-> P;
            N < P;
            P < N2;
        }
        without {
            N -[case]-> P2;
            P2 < N;
            P2 [lemma="from"]
        }
        commands {N.Cxn=NPN}
    }

    rule npn_bis {
        pattern {
            N [ xpos = re"N.*", Cxn<>re".*NPN.*"];
            N2 [xpos = re"N.*" ];
            N.lemma = N2.lemma;
            N -> N2;
            N2 -[case]-> P;
            N < P;
            P < N2;
        }
        without {
            N -[case]-> P2;
            P2 < N;
            P2 [lemma="from"]
        }
        commands {N.Cxn=N.Cxn + "," + "NPN"}
    }
}