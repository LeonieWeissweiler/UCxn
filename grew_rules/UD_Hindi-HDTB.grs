strat main { 
  Seq(
    Onf(conditionals),
    Onf(existentials),
    Onf(interrogatives),
    Onf(npn),
    Onf(resultatives)
  )
}

package conditionals {

    rule conditional-realistic { % Conditionals - realistic type, without inversion, with explicit protasis marker
        pattern { 
            N [form="अगर"|"यदि"];
            T [form="तो"];
            V2 -[mark]-> T;
            V2[!Cxn];
        }
        without { V1 [upos="VERB", Mood="Sub"] }
        commands { V2.Cxn=Conditional }
    }

    rule conditional-realistic2 { % Conditionals - realistic type, if-X-only-then, without inversion, with explicit protasis marker
        pattern { 
            N [form="अगर"|"यदि"];
            T [form="तब"];
            H [form="ही"];
            T -[dep]-> H;
            V1 [upos=VERB];
            V2 [upos=VERB];
            V1 -[mark]-> N;
            V2 -[advcl]-> V1;
            V2 -[obl]-> T;
            V2[!Cxn];
        }
        commands { V2.Cxn=Conditional }
    }

    rule conditional-inverted { % Conditionals - inverted
        pattern {
            N [form="अगर"|"यदि"];
            V1 -[mark]-> N;
            V2 -> V1;
            V2[!Cxn];
        }
        without { T [form="तो"] }
        commands { V2.Cxn=Conditional }
    }

    rule conditional-subjprot-explicit { % Conditionals - subjunctive protasis with explicit protasis marker
        pattern {
            V1 [upos="VERB", Mood="Sub"];
            V2 [upos="VERB"];
            N [form="अगर"|"यदि"];
            T [form="तो"];
            V2 -[mark]-> T;
            V2 -[advcl]-> V1;
            V2[!Cxn];
        }
        without { K1 [form="कभी"]; V1-> K1; K2 [form="कभी"]; V2-> K2 }
        commands { V2.Cxn=Conditional }
    }

    rule conditional-subjprot-notexplicit { % Conditionals - subjunctive protasis without explicit protasis marker
        pattern {
            V1 [upos="VERB", Mood="Sub"];
            V2 [upos="VERB"];
            T [form="तो"];
            V2 -[mark]-> T;
            V2 -[advcl]-> V1;
            V2[!Cxn];
        }
        without { N [form="अगर"|"यदि"] }
        without { K1 [form="कभी"]; V1-> K1; K2 [form="कभी"]; V2-> K2 }
        commands { V2.Cxn=Conditional }
    }

    rule conditional-pos-epist-hyp { % Conditionals - positive epistemic stance hypothetical conditional
        pattern {
            SC [form="ताकि"];
            J [form="जब"];
            T [form="तो"];
            V -> T;
            V -[mark]-> SC;
            V[!Cxn];
        }
        commands { V.Cxn=Conditional }
    }

    rule conditional-pos-epist-realistic { % Conditionals - positive epistemic stance realistic conditional
        pattern {
            T [form="तो"];
            J [form="जब"];
            VJ [Aspect <> Perf];
            VJ -> J;
            V2 -> T;
            V2[!Cxn];
        }
        without { A [upos=AUX, Tense=Past]; VJ -[aux]-> A }
        commands { V2.Cxn=Conditional }
    }
}

package existentials {

    rule exist1{ 

        pattern {
            W1 [lemma="है", upos="AUX"];
            W2 [upos <> ADJ|ADJ-DET|DET];
            W2 -[cop]-> W1;
            W1[!Cxn];
        }
        commands { W1.Cxn=Existential }
    }

    rule exist1_bis{
        pattern {
            W1 [lemma="है", upos="AUX"];
            W2 [upos <> ADJ|ADJ-DET|DET];
            W2 -[cop]-> W1;
            W1[Cxn<>re".*Existential.*"];
        }
        commands { W1.Cxn= W1.Cxn + "," + "Existential" }
    }
}

package interrogatives {

    rule int-direct-info { % Interrogatives - Direct information questions
        pattern {
            W [lemma="क्या"|"कौन"|"कहाँ"|"कहां"|"कब"|"कैसे"|"कितना"|"किस"];
            V -> W;
            V[!Cxn];
        }
        without { SC [form="कि"]; V -[mark]-> SC }
        without { V1 [upos=VERB]; V1 -[advcl]-> V; }
        commands { V.Cxn=Interrogative }
    }

    rule int-direct-info_bis { % Interrogatives - Direct information questions
        pattern {
            W [lemma="क्या"|"कौन"|"कहाँ"|"कहां"|"कब"|"कैसे"|"कितना"|"किस"];
            V -> W;
            V[Cxn<>re".*Interrogative.*"];
        }
        without { SC [form="कि"]; V -[mark]-> SC }
        without { V1 [upos=VERB]; V1 -[advcl]-> V; }
        commands { V.Cxn=V.Cxn + "," + "Interrogative" }
    }  

    rule int-indirect-info { % Interrogatives - Indirect information questions
        pattern {
            W [lemma="क्या"|"कौन"|"कहाँ"|"कहां"|"कब"|"कैसे"|"कितना"|"किस"];
            SC [form="कि"]; V [upos=VERB]; V -> W; V -[mark]-> SC;
            V[!Cxn];
        }
        commands { V.Cxn=Interrogative }
    }

    rule int-indirect-info_bis { % Interrogatives - Indirect information questions
        pattern {
            W [lemma="क्या"|"कौन"|"कहाँ"|"कहां"|"कब"|"कैसे"|"कितना"|"किस"];
            SC [form="कि"]; V [upos=VERB]; V -> W; V -[mark]-> SC;
            V[Cxn<>re".*Interrogative.*"];
        }
        commands { V.Cxn=V.Cxn + "," + "Interrogative" }
    }

    rule int-direct-polar { % Interrogatives - Direct polar questions
        pattern {
            W [lemma="क्या", upos=ADV];
            V -> W;
            V[!Cxn];
        }
        without { SC [form="कि"]; V -[mark]-> SC }
        without { V1 [upos=VERB]; V1 -[advcl]-> V; }
        commands { V.Cxn=Interrogative }
    }

    rule int-direct-polar_bis { % Interrogatives - Direct polar questions
        pattern {
            W [lemma="क्या", upos=ADV];
            V -> W;
            V[Cxn<>re".*Interrogative.*"];
        }
        without { SC [form="कि"]; V -[mark]-> SC }
        without { V1 [upos=VERB]; V1 -[advcl]-> V; }
        commands { V.Cxn=V.Cxn + "," + "Interrogative" }
    }

    rule int-indirect-polar { % Interrogatives - Indirect polar questions
        pattern {
            W [lemma="क्या"];
            ROOT -["advmod"]-> W;
            V -> W;
            V[!Cxn];
        }
        commands { V.Cxn=Interrogative }
    }

    rule int-indirect-polar_bis { % Interrogatives - Indirect polar questions
        pattern {
            W [lemma="क्या"];
            ROOT -["advmod"]-> W;
            V -> W;
            V[Cxn<>re".*Interrogative.*"];
        }
        commands { V.Cxn=V.Cxn + "," + "Interrogative" }
    }

}

package npn {

    rule NPN-succession { % NPN Succession
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P [upos="ADP", lemma="ब"];
            N1 < P;
            P < N2;
            P[!Cxn];
        }
        commands { P.Cxn=NPN }
    }

    rule NPN-succession_bis { % NPN Succession
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P [upos="ADP", lemma="ब"];
            N1 < P;
            P < N2;
            P[Cxn<>re".*NPN.*"]
        }
        commands { P.Cxn=P.Cxn + "," + "NPN" }
    }


    rule NPN-comparison { % NPN Comparison
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P1 [upos="ADP", lemma="के"];
            P2 [upos="ADP", lemma="बदले"];
            P1 < P2;
            N1 -[case]-> P1;
            N1 -[case]-> P2;
            N1 < P1;
            P2 < N2;
            P1[!Cxn];
        }
        commands { P1.Cxn=NPN }
    }

    rule NPN-comparison_bis { % NPN Comparison
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P1 [upos="ADP", lemma="के"];
            P2 [upos="ADP", lemma="बदले"];
            P1 < P2;
            N1 -[case]-> P1;
            N1 -[case]-> P2;
            N1 < P1;
            P2 < N2;
            P1[Cxn<>re".*NPN.*"]
        }
        commands { P1.Cxn=P1.Cxn + "," + "NPN" }
    }

    rule NPN-opposition { % NPN Opposition
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P1 [upos="ADP", lemma="के"];
            P2 [upos="ADP", lemma="खिलाफ"];
            P1 < P2;
            N1 -[case]-> P1;
            N1 -[case]-> P2;
            N1 < P1;
            P2 < N2;
            P1[!Cxn];
        }
        commands { P1.Cxn=NPN }
    }

    rule NPN-opposition_bis { % NPN Opposition
        pattern {
            N1 [upos="NOUN"];
            N2 [upos="NOUN"];
            N1.lemma = N2.lemma;
            P1 [upos="ADP", lemma="के"];
            P2 [upos="ADP", lemma="खिलाफ"];
            P1 < P2;
            N1 -[case]-> P1;
            N1 -[case]-> P2;
            N1 < P1;
            P2 < N2;
            P1[Cxn<>re".*NPN.*"]
        }
        commands { P1.Cxn=P1.Cxn + "," + "NPN" }
    }

}

package resultatives {
    rule resultative-VV { 
        pattern {
            V1 [upos="VERB", Vib="0"];
            V2 [upos="VERB", lemma="भगा"|"गिरा"|"बिखर"];
            V2 -["advcl"]-> V1;
            V2[!Cxn];
        }
        commands { V2.Cxn=Resultative }
    }

    rule resultative-VV_bis { 
        pattern {
            V1 [upos="VERB", Vib="0"];
            V2 [upos="VERB", lemma="भगा"|"गिरा"|"बिखर"];
            V2 -["advcl"]-> V1;
            V2[Cxn<>re".*Resultative.*"];
        }
        commands { V2.Cxn=V2.Cxn + "," + "Resultative" }
    }

}






































